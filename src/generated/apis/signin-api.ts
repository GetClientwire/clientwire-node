/* tslint:disable */
/* eslint-disable */
/**
 * Wire API (development)
 * The API for the Clientwire messaging service.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@clientwire.net
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AuthenticationOptions,
  TokenResponseDto,
} from '../models/index';
import {
    AuthenticationOptionsFromJSON,
    AuthenticationOptionsToJSON,
    TokenResponseDtoFromJSON,
    TokenResponseDtoToJSON,
} from '../models/index';

export interface Oauth2TokenEndpointRequest {
    tenantId: string | null;
    grantType?: string | null;
    clientId?: string | null;
    clientSecret?: string | null;
    scope?: string | null;
    username?: string | null;
    password?: string | null;
    subjectToken?: string | null;
    subjectTokenType?: string | null;
    code?: string | null;
    redirectUri?: string | null;
    codeVerifier?: string | null;
    providerName?: string | null;
    refreshToken?: string | null;
}

export interface SigninOptionsRequest {
    tenantId: string;
    email: string;
}

/**
 * SigninApi - interface
 * 
 * @export
 * @interface SigninApiInterface
 */
export interface SigninApiInterface {
    /**
     * OAuth2-style token endpoint.  Supports multiple grant_type values:  - authorization_code  (PKCE optional) // NOT YET IMPLEMENTED  - password            (ROPC)  - refresh_token  - urn:ietf:params:oauth:grant-type:token-exchange (Token Exchange)   For the Token Exchange grant_type, the subject_token_type can be:  - urn:clientwire:token-type:client-participant-auth-key  - urn:ietf:params:oauth:token-type:access_token   urn:clientwire:token-type:client-participant-auth-key is a special token type for exchanging a client\'s participant auth key for an access token. urn:ietf:params:oauth:token-type:access_token is for our token-exchange service to exchange your access token with a Clientwire access token by verifying it at your provided userinfo endpoint. 
     * @summary OAuth2 Token Endpoint
     * @param {string} tenantId 
     * @param {string} [grantType] 
     * @param {string} [clientId] 
     * @param {string} [clientSecret] 
     * @param {string} [scope] 
     * @param {string} [username] 
     * @param {string} [password] 
     * @param {string} [subjectToken] 
     * @param {string} [subjectTokenType] 
     * @param {string} [code] 
     * @param {string} [redirectUri] 
     * @param {string} [codeVerifier] 
     * @param {string} [providerName] 
     * @param {string} [refreshToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigninApiInterface
     */
    oauth2TokenEndpointRaw(requestParameters: Oauth2TokenEndpointRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TokenResponseDto>>;

    /**
     * OAuth2-style token endpoint.  Supports multiple grant_type values:  - authorization_code  (PKCE optional) // NOT YET IMPLEMENTED  - password            (ROPC)  - refresh_token  - urn:ietf:params:oauth:grant-type:token-exchange (Token Exchange)   For the Token Exchange grant_type, the subject_token_type can be:  - urn:clientwire:token-type:client-participant-auth-key  - urn:ietf:params:oauth:token-type:access_token   urn:clientwire:token-type:client-participant-auth-key is a special token type for exchanging a client\'s participant auth key for an access token. urn:ietf:params:oauth:token-type:access_token is for our token-exchange service to exchange your access token with a Clientwire access token by verifying it at your provided userinfo endpoint. 
     * OAuth2 Token Endpoint
     */
    oauth2TokenEndpoint(requestParameters: Oauth2TokenEndpointRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TokenResponseDto>;

    /**
     * Based on the tenant_id and the email, we lookup what options for signin are available.
     * @summary Returns a list of signin options of the user.
     * @param {string} tenantId 
     * @param {string} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SigninApiInterface
     */
    signinOptionsRaw(requestParameters: SigninOptionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthenticationOptions>>;

    /**
     * Based on the tenant_id and the email, we lookup what options for signin are available.
     * Returns a list of signin options of the user.
     */
    signinOptions(requestParameters: SigninOptionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthenticationOptions>;

}

/**
 * 
 */
export class SigninApi extends runtime.BaseAPI implements SigninApiInterface {

    /**
     * OAuth2-style token endpoint.  Supports multiple grant_type values:  - authorization_code  (PKCE optional) // NOT YET IMPLEMENTED  - password            (ROPC)  - refresh_token  - urn:ietf:params:oauth:grant-type:token-exchange (Token Exchange)   For the Token Exchange grant_type, the subject_token_type can be:  - urn:clientwire:token-type:client-participant-auth-key  - urn:ietf:params:oauth:token-type:access_token   urn:clientwire:token-type:client-participant-auth-key is a special token type for exchanging a client\'s participant auth key for an access token. urn:ietf:params:oauth:token-type:access_token is for our token-exchange service to exchange your access token with a Clientwire access token by verifying it at your provided userinfo endpoint. 
     * OAuth2 Token Endpoint
     */
    async oauth2TokenEndpointRaw(requestParameters: Oauth2TokenEndpointRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TokenResponseDto>> {
        if (requestParameters['tenantId'] == null) {
            throw new runtime.RequiredError(
                'tenantId',
                'Required parameter "tenantId" was null or undefined when calling oauth2TokenEndpoint().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['grantType'] != null) {
            formParams.append('grant_type', requestParameters['grantType'] as any);
        }

        if (requestParameters['clientId'] != null) {
            formParams.append('client_id', requestParameters['clientId'] as any);
        }

        if (requestParameters['clientSecret'] != null) {
            formParams.append('client_secret', requestParameters['clientSecret'] as any);
        }

        if (requestParameters['scope'] != null) {
            formParams.append('scope', requestParameters['scope'] as any);
        }

        if (requestParameters['username'] != null) {
            formParams.append('username', requestParameters['username'] as any);
        }

        if (requestParameters['password'] != null) {
            formParams.append('password', requestParameters['password'] as any);
        }

        if (requestParameters['subjectToken'] != null) {
            formParams.append('subject_token', requestParameters['subjectToken'] as any);
        }

        if (requestParameters['subjectTokenType'] != null) {
            formParams.append('subject_token_type', requestParameters['subjectTokenType'] as any);
        }

        if (requestParameters['code'] != null) {
            formParams.append('code', requestParameters['code'] as any);
        }

        if (requestParameters['redirectUri'] != null) {
            formParams.append('redirect_uri', requestParameters['redirectUri'] as any);
        }

        if (requestParameters['codeVerifier'] != null) {
            formParams.append('code_verifier', requestParameters['codeVerifier'] as any);
        }

        if (requestParameters['providerName'] != null) {
            formParams.append('provider_name', requestParameters['providerName'] as any);
        }

        if (requestParameters['refreshToken'] != null) {
            formParams.append('refresh_token', requestParameters['refreshToken'] as any);
        }

        const response = await this.request({
            path: `/api/v1/auth/{tenant_id}/oauth2/token`.replace(`{${"tenant_id"}}`, encodeURIComponent(String(requestParameters['tenantId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TokenResponseDtoFromJSON(jsonValue));
    }

    /**
     * OAuth2-style token endpoint.  Supports multiple grant_type values:  - authorization_code  (PKCE optional) // NOT YET IMPLEMENTED  - password            (ROPC)  - refresh_token  - urn:ietf:params:oauth:grant-type:token-exchange (Token Exchange)   For the Token Exchange grant_type, the subject_token_type can be:  - urn:clientwire:token-type:client-participant-auth-key  - urn:ietf:params:oauth:token-type:access_token   urn:clientwire:token-type:client-participant-auth-key is a special token type for exchanging a client\'s participant auth key for an access token. urn:ietf:params:oauth:token-type:access_token is for our token-exchange service to exchange your access token with a Clientwire access token by verifying it at your provided userinfo endpoint. 
     * OAuth2 Token Endpoint
     */
    async oauth2TokenEndpoint(requestParameters: Oauth2TokenEndpointRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TokenResponseDto> {
        const response = await this.oauth2TokenEndpointRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Based on the tenant_id and the email, we lookup what options for signin are available.
     * Returns a list of signin options of the user.
     */
    async signinOptionsRaw(requestParameters: SigninOptionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AuthenticationOptions>> {
        if (requestParameters['tenantId'] == null) {
            throw new runtime.RequiredError(
                'tenantId',
                'Required parameter "tenantId" was null or undefined when calling signinOptions().'
            );
        }

        if (requestParameters['email'] == null) {
            throw new runtime.RequiredError(
                'email',
                'Required parameter "email" was null or undefined when calling signinOptions().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['email'] != null) {
            queryParameters['email'] = requestParameters['email'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/auth/{tenant_id}/options`.replace(`{${"tenant_id"}}`, encodeURIComponent(String(requestParameters['tenantId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AuthenticationOptionsFromJSON(jsonValue));
    }

    /**
     * Based on the tenant_id and the email, we lookup what options for signin are available.
     * Returns a list of signin options of the user.
     */
    async signinOptions(requestParameters: SigninOptionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AuthenticationOptions> {
        const response = await this.signinOptionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
