/* tslint:disable */
/* eslint-disable */
/**
 * Wire API (development)
 * The API for the Clientwire messaging service.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@clientwire.net
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  LocationWithAddress,
} from '../models/index';
import {
    LocationWithAddressFromJSON,
    LocationWithAddressToJSON,
} from '../models/index';

export interface ReverseGeocodeRequest {
    latitude?: number;
    longitude?: number;
}

export interface SearchGeocodeRequest {
    text: string;
}

export interface SearchStructuredGeocodeRequest {
    street: string;
    country?: string | null;
    postalCode?: number | null;
}

/**
 * GeocodingApi - interface
 * 
 * @export
 * @interface GeocodingApiInterface
 */
export interface GeocodingApiInterface {
    /**
     * Given latitude/longitude, returns the address.
     * @summary Reverse geocode a location.
     * @param {number} [latitude] 
     * @param {number} [longitude] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeocodingApiInterface
     */
    reverseGeocodeRaw(requestParameters: ReverseGeocodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LocationWithAddress>>;

    /**
     * Given latitude/longitude, returns the address.
     * Reverse geocode a location.
     */
    reverseGeocode(requestParameters: ReverseGeocodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LocationWithAddress>;

    /**
     * Given a text query, returns a geocoded address.
     * @summary Search for a location.
     * @param {string} text 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeocodingApiInterface
     */
    searchGeocodeRaw(requestParameters: SearchGeocodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LocationWithAddress>>;

    /**
     * Given a text query, returns a geocoded address.
     * Search for a location.
     */
    searchGeocode(requestParameters: SearchGeocodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LocationWithAddress>;

    /**
     * Given partial address fields, returns a geocoded address.
     * @summary Search for a location (structured).
     * @param {string} street 
     * @param {string} [country] 
     * @param {number} [postalCode] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GeocodingApiInterface
     */
    searchStructuredGeocodeRaw(requestParameters: SearchStructuredGeocodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LocationWithAddress>>;

    /**
     * Given partial address fields, returns a geocoded address.
     * Search for a location (structured).
     */
    searchStructuredGeocode(requestParameters: SearchStructuredGeocodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LocationWithAddress>;

}

/**
 * 
 */
export class GeocodingApi extends runtime.BaseAPI implements GeocodingApiInterface {

    /**
     * Given latitude/longitude, returns the address.
     * Reverse geocode a location.
     */
    async reverseGeocodeRaw(requestParameters: ReverseGeocodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LocationWithAddress>> {
        const queryParameters: any = {};

        if (requestParameters['latitude'] != null) {
            queryParameters['latitude'] = requestParameters['latitude'];
        }

        if (requestParameters['longitude'] != null) {
            queryParameters['longitude'] = requestParameters['longitude'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-KEY"] = await this.configuration.apiKey("X-API-KEY"); // ApiKeyAuth authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", ["CLIENT_PARTICIPANT", "USER", "OWNER", "API_KEY"]);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/geocoder/reverse`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LocationWithAddressFromJSON(jsonValue));
    }

    /**
     * Given latitude/longitude, returns the address.
     * Reverse geocode a location.
     */
    async reverseGeocode(requestParameters: ReverseGeocodeRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LocationWithAddress> {
        const response = await this.reverseGeocodeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Given a text query, returns a geocoded address.
     * Search for a location.
     */
    async searchGeocodeRaw(requestParameters: SearchGeocodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LocationWithAddress>> {
        if (requestParameters['text'] == null) {
            throw new runtime.RequiredError(
                'text',
                'Required parameter "text" was null or undefined when calling searchGeocode().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['text'] != null) {
            queryParameters['text'] = requestParameters['text'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-KEY"] = await this.configuration.apiKey("X-API-KEY"); // ApiKeyAuth authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", ["CLIENT_PARTICIPANT", "USER", "OWNER", "API_KEY"]);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/geocoder/search`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LocationWithAddressFromJSON(jsonValue));
    }

    /**
     * Given a text query, returns a geocoded address.
     * Search for a location.
     */
    async searchGeocode(requestParameters: SearchGeocodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LocationWithAddress> {
        const response = await this.searchGeocodeRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Given partial address fields, returns a geocoded address.
     * Search for a location (structured).
     */
    async searchStructuredGeocodeRaw(requestParameters: SearchStructuredGeocodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LocationWithAddress>> {
        if (requestParameters['street'] == null) {
            throw new runtime.RequiredError(
                'street',
                'Required parameter "street" was null or undefined when calling searchStructuredGeocode().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['country'] != null) {
            queryParameters['country'] = requestParameters['country'];
        }

        if (requestParameters['postalCode'] != null) {
            queryParameters['postalCode'] = requestParameters['postalCode'];
        }

        if (requestParameters['street'] != null) {
            queryParameters['street'] = requestParameters['street'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-KEY"] = await this.configuration.apiKey("X-API-KEY"); // ApiKeyAuth authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", ["CLIENT_PARTICIPANT", "USER", "OWNER", "API_KEY"]);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/geocoder/search/structured`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LocationWithAddressFromJSON(jsonValue));
    }

    /**
     * Given partial address fields, returns a geocoded address.
     * Search for a location (structured).
     */
    async searchStructuredGeocode(requestParameters: SearchStructuredGeocodeRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LocationWithAddress> {
        const response = await this.searchStructuredGeocodeRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
