/* tslint:disable */
/* eslint-disable */
/**
 * Wire API (development)
 * The API for the Clientwire messaging service.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@clientwire.net
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  RotateWebhookSecretRequest,
  TenantWebhookSettings,
  UpdateWebhookSettingsRequest,
} from '../models/index';
import {
    RotateWebhookSecretRequestFromJSON,
    RotateWebhookSecretRequestToJSON,
    TenantWebhookSettingsFromJSON,
    TenantWebhookSettingsToJSON,
    UpdateWebhookSettingsRequestFromJSON,
    UpdateWebhookSettingsRequestToJSON,
} from '../models/index';

export interface RotateWebhooksSecretRequest {
    rotateWebhookSecretRequest: RotateWebhookSecretRequest;
}

export interface SetWebhookSettingsRequest {
    updateWebhookSettingsRequest: UpdateWebhookSettingsRequest;
}

/**
 * WebhooksApi - interface
 * 
 * @export
 * @interface WebhooksApiInterface
 */
export interface WebhooksApiInterface {
    /**
     * Returns the current endpoint URL, signature scheme, and the secret in plain text. 
     * @summary Get the tenant’s webhook settings.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApiInterface
     */
    getWebhookSettingsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TenantWebhookSettings>>;

    /**
     * Returns the current endpoint URL, signature scheme, and the secret in plain text. 
     * Get the tenant’s webhook settings.
     */
    getWebhookSettings(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TenantWebhookSettings>;

    /**
     * Generates a new random whsec_ secret, encrypts, and saves it.
     * @summary Rotate the webhook secret. Optionally update the signature scheme.
     * @param {RotateWebhookSecretRequest} rotateWebhookSecretRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApiInterface
     */
    rotateWebhooksSecretRaw(requestParameters: RotateWebhooksSecretRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TenantWebhookSettings>>;

    /**
     * Generates a new random whsec_ secret, encrypts, and saves it.
     * Rotate the webhook secret. Optionally update the signature scheme.
     */
    rotateWebhooksSecret(requestParameters: RotateWebhooksSecretRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TenantWebhookSettings>;

    /**
     * Allows setting the endpoint_url field. If the row doesn\'t exist, it will be created.
     * @summary Update or create webhook settings (endpoint URL only).
     * @param {UpdateWebhookSettingsRequest} updateWebhookSettingsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApiInterface
     */
    setWebhookSettingsRaw(requestParameters: SetWebhookSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TenantWebhookSettings>>;

    /**
     * Allows setting the endpoint_url field. If the row doesn\'t exist, it will be created.
     * Update or create webhook settings (endpoint URL only).
     */
    setWebhookSettings(requestParameters: SetWebhookSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TenantWebhookSettings>;

    /**
     *              Enqueues a \"test.webhook\" event to be sent to your currently configured             webhook endpoint. This can help you verify your endpoint is receiving and             verifying Standard Webhooks signatures correctly.                          **Important**: Make sure you\'ve set your webhook endpoint URL              via `PUT /api/v1/webhook-settings` before calling this.                          The test event payload is:             ```             {               \"type\": \"test.webhook\",               \"timestamp\": \"2025-01-01T12:00:00Z\",               \"data\": {                 \"example\": \"Hello World!\"               }             }             ```             The event is signed using your stored secret,              then delivered to the endpoint URL with standard headers:             - `webhook-id`: a unique message ID              - `webhook-timestamp`: an integer (Unix seconds)             - `webhook-signature`: the signature(s), e.g. `v1,...`             If the endpoint responds with a 2xx status, the queue marks it successful.              Otherwise, the queue retries automatically, up to 6 times.         
     * @summary Trigger a test webhook event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhooksApiInterface
     */
    triggerTestWebhookRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>>;

    /**
     *              Enqueues a \"test.webhook\" event to be sent to your currently configured             webhook endpoint. This can help you verify your endpoint is receiving and             verifying Standard Webhooks signatures correctly.                          **Important**: Make sure you\'ve set your webhook endpoint URL              via `PUT /api/v1/webhook-settings` before calling this.                          The test event payload is:             ```             {               \"type\": \"test.webhook\",               \"timestamp\": \"2025-01-01T12:00:00Z\",               \"data\": {                 \"example\": \"Hello World!\"               }             }             ```             The event is signed using your stored secret,              then delivered to the endpoint URL with standard headers:             - `webhook-id`: a unique message ID              - `webhook-timestamp`: an integer (Unix seconds)             - `webhook-signature`: the signature(s), e.g. `v1,...`             If the endpoint responds with a 2xx status, the queue marks it successful.              Otherwise, the queue retries automatically, up to 6 times.         
     * Trigger a test webhook event
     */
    triggerTestWebhook(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void>;

}

/**
 * 
 */
export class WebhooksApi extends runtime.BaseAPI implements WebhooksApiInterface {

    /**
     * Returns the current endpoint URL, signature scheme, and the secret in plain text. 
     * Get the tenant’s webhook settings.
     */
    async getWebhookSettingsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TenantWebhookSettings>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-KEY"] = await this.configuration.apiKey("X-API-KEY"); // ApiKeyAuth authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", ["OWNER", "API_KEY"]);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/webhook-settings`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TenantWebhookSettingsFromJSON(jsonValue));
    }

    /**
     * Returns the current endpoint URL, signature scheme, and the secret in plain text. 
     * Get the tenant’s webhook settings.
     */
    async getWebhookSettings(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TenantWebhookSettings> {
        const response = await this.getWebhookSettingsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Generates a new random whsec_ secret, encrypts, and saves it.
     * Rotate the webhook secret. Optionally update the signature scheme.
     */
    async rotateWebhooksSecretRaw(requestParameters: RotateWebhooksSecretRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TenantWebhookSettings>> {
        if (requestParameters['rotateWebhookSecretRequest'] == null) {
            throw new runtime.RequiredError(
                'rotateWebhookSecretRequest',
                'Required parameter "rotateWebhookSecretRequest" was null or undefined when calling rotateWebhooksSecret().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-KEY"] = await this.configuration.apiKey("X-API-KEY"); // ApiKeyAuth authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", ["OWNER", "API_KEY"]);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/webhook-settings/rotate-secret`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RotateWebhookSecretRequestToJSON(requestParameters['rotateWebhookSecretRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TenantWebhookSettingsFromJSON(jsonValue));
    }

    /**
     * Generates a new random whsec_ secret, encrypts, and saves it.
     * Rotate the webhook secret. Optionally update the signature scheme.
     */
    async rotateWebhooksSecret(requestParameters: RotateWebhooksSecretRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TenantWebhookSettings> {
        const response = await this.rotateWebhooksSecretRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Allows setting the endpoint_url field. If the row doesn\'t exist, it will be created.
     * Update or create webhook settings (endpoint URL only).
     */
    async setWebhookSettingsRaw(requestParameters: SetWebhookSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TenantWebhookSettings>> {
        if (requestParameters['updateWebhookSettingsRequest'] == null) {
            throw new runtime.RequiredError(
                'updateWebhookSettingsRequest',
                'Required parameter "updateWebhookSettingsRequest" was null or undefined when calling setWebhookSettings().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-KEY"] = await this.configuration.apiKey("X-API-KEY"); // ApiKeyAuth authentication
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", ["OWNER", "API_KEY"]);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/webhook-settings`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateWebhookSettingsRequestToJSON(requestParameters['updateWebhookSettingsRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TenantWebhookSettingsFromJSON(jsonValue));
    }

    /**
     * Allows setting the endpoint_url field. If the row doesn\'t exist, it will be created.
     * Update or create webhook settings (endpoint URL only).
     */
    async setWebhookSettings(requestParameters: SetWebhookSettingsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TenantWebhookSettings> {
        const response = await this.setWebhookSettingsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     *              Enqueues a \"test.webhook\" event to be sent to your currently configured             webhook endpoint. This can help you verify your endpoint is receiving and             verifying Standard Webhooks signatures correctly.                          **Important**: Make sure you\'ve set your webhook endpoint URL              via `PUT /api/v1/webhook-settings` before calling this.                          The test event payload is:             ```             {               \"type\": \"test.webhook\",               \"timestamp\": \"2025-01-01T12:00:00Z\",               \"data\": {                 \"example\": \"Hello World!\"               }             }             ```             The event is signed using your stored secret,              then delivered to the endpoint URL with standard headers:             - `webhook-id`: a unique message ID              - `webhook-timestamp`: an integer (Unix seconds)             - `webhook-signature`: the signature(s), e.g. `v1,...`             If the endpoint responds with a 2xx status, the queue marks it successful.              Otherwise, the queue retries automatically, up to 6 times.         
     * Trigger a test webhook event
     */
    async triggerTestWebhookRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", ["OWNER", "API_KEY"]);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const response = await this.request({
            path: `/api/v1/webhook-settings/test`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     *              Enqueues a \"test.webhook\" event to be sent to your currently configured             webhook endpoint. This can help you verify your endpoint is receiving and             verifying Standard Webhooks signatures correctly.                          **Important**: Make sure you\'ve set your webhook endpoint URL              via `PUT /api/v1/webhook-settings` before calling this.                          The test event payload is:             ```             {               \"type\": \"test.webhook\",               \"timestamp\": \"2025-01-01T12:00:00Z\",               \"data\": {                 \"example\": \"Hello World!\"               }             }             ```             The event is signed using your stored secret,              then delivered to the endpoint URL with standard headers:             - `webhook-id`: a unique message ID              - `webhook-timestamp`: an integer (Unix seconds)             - `webhook-signature`: the signature(s), e.g. `v1,...`             If the endpoint responds with a 2xx status, the queue marks it successful.              Otherwise, the queue retries automatically, up to 6 times.         
     * Trigger a test webhook event
     */
    async triggerTestWebhook(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.triggerTestWebhookRaw(initOverrides);
    }

}
